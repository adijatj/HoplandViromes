Load libraries
```{r}
library(igraph)
library(GGally)
library(tidyverse)
```

Load data 
We need two files:
- Network file - this is the c1.ntw file generated by vConTACT2 and contains each pair of viral genomes with a significant overlap in their gene content.
- Functional annotation file - a data frame containing a list of vOTUs (first column) and associated attributes. 
```{r}
adj.method <- "holm"

ntwk <-read.table("../Data/c1.ntw", header = F, sep = " ", col.names = c("OTU1", "OTU2", "Score"))

fnct.trt <- readRDS("../Data/votu_indicator.RDS") %>%
  dplyr::rename("Genome" = "OTU_ID") 

fnct.trt %>% 
  group_by(Response) %>% 
  count()
```

Filter data
Make sure to remove all vOTUs that are not shared across the nodes, edges, and functional annotation data frames
```{r}
fnct.trt.filt <- fnct.trt %>% 
  filter(Genome %in% ntwk$OTU1 | Genome %in% ntwk$OTU2)

good.genomes <- unique(fnct.trt.filt$Genome)

ntwk.filt <- ntwk  %>%
  filter(OTU1 %in% good.genomes & OTU2 %in% good.genomes)
```

Generate the 2D network layout with the filtered data
Note: Make sure to use a force-directed network layout algorithm to generate the 2D configuration of the network. 
The two modes available in ggnet2 are the "Fruchterman-Reingold" (mode = "fruchtermanreingold") and the Kamada-Kawai (mode = "kamadakawai") algorithms. 
```{r}
layout <- "fruchtermanreingold"

nodes <- GGally::ggnet2(as.matrix(ntwk.filt[,-3]), 
                mode = layout, 
                layout.par = list(list=(niter=2000))) %>% 
  .$data %>% 
  dplyr::rename("Genome" = "label")

edges <- ntwk.filt %>% 
  mutate(Pair = paste(OTU1, OTU2, sep = ".")) %>% 
  gather(key = "Member", value = "Genome", -Pair, -Score) %>% 
  inner_join(nodes, by = "Genome")
```

Generate igraph object
Note: When calculating weight-based distances, igraph sums the weights linked to each pair. Since the weights generated by vConTACT2 are the -log10(P-vals) of hypergeometric tests, higher values denote closer similarities between pairs of genomes. Therefore, we need to transform the vConTACT scores into inverse values (weight = 1/Score) so that the shortest paths found by igraph are between more closely related nodes. An alternative is to transform the vConTACT scores to P-values but I have found that they can be extremely small (10^-300) which can mess up with the neighborhood calculations (igraph turns very small values into zeros). Potentially, we could multiply the P-values by the inverse of the smallest P-value (weight = (10^-Score)*10^max(ntwk.filt$Score)) but I haven't checked if that messes up with downstream calculations
```{r}
edges.igraph <- ntwk.filt %>% 
  mutate(weight = 1/Score) %>% 
  select(OTU1, OTU2, weight) 

nodes.igraph <- select(nodes, Genome) 

ntwk.igraph <- graph_from_data_frame(d = edges.igraph, vertices = nodes.igraph, directed = F)
```

Calculate distances
```{r}
### Weighted distances
ntwk.dist <- distances(ntwk.igraph) 
```

Calculate distance threshold
Plot distribution of distances
```{r}
dist.filt <- ntwk.dist[upper.tri(ntwk.dist)]  ## We want to get rid of redundant values by removing the diagonal and the lower triangle before calculating the minimum distance

min.dist <- quantile(dist.filt, .01)
good.dist <- ntwk.dist < min.dist

edges %>% 
  mutate(weight = 1/Score) %>% 
  ggplot(aes(weight)) +
  geom_histogram(fill = "gray85") + 
  theme_bw()

edges %>% 
  ggplot(aes(Score)) +
  geom_histogram(fill = "gray85") +
  theme_bw()

ggplot(data = data.frame(Distance = dist.filt), aes(Distance)) + 
  geom_histogram(fill = "gray85") + 
  geom_vline(xintercept = c(min.dist), linetype = 2) +
  theme_bw()
```

Identify the neighborhood based on the distance threshold
```{r}
nodes.ids <- nodes$Genome %>% unique()

neighborhood.list <- list()
nhood.length.list <- list()

for(node in nodes.ids){
  neighborhood <- good.dist[,node][good.dist[,node] == T] %>% names()
  neighborhood.list[[node]] <- neighborhood
  nhood.length.list[[node]] <- length(neighborhood)
}

nhood.length <- plyr::ldply(nhood.length.list, function(x) x)
names(nhood.length) <- c("Neighborhood", "Size")

nhood.length %>% 
  ggplot(aes(Size)) +
  geom_histogram(fill = "gray85", binwidth = 5) + 
  geom_vline(xintercept = 10, linetype = 2) +
  theme_bw()
```

Calculate enriched neighborhoods for each trait 
```{r}
sig.otus <- fnct.trt.filt %>%
  filter(p.value < 0.05) %>%
  mutate(Trait = Response)

enrichment.list.trt <- list()

for(trait in unique(sig.otus$Trait)){
  sig.trait <- filter(sig.otus, Trait == trait)$Genome
  hgt.list <- list()
  for(node in nodes.ids){
    neighborhood <- neighborhood.list[[node]]
    neighborhood.positive <- sum(neighborhood %in% sig.trait)
    universe.positive <- sum(nodes.ids %in% sig.trait)
    universe.negative <- sum(!nodes.ids %in% sig.trait)
    neighborhood.size<- length(neighborhood)
    hgt.list[[node]] <- phyper(neighborhood.positive, universe.positive, universe.negative, neighborhood.size, lower.tail = F)
  }
  hgt <- plyr::ldply(hgt.list, function(x) x)
  names(hgt) <- c("Neighborhood", "pval")
  enrichment.list.trt[[trait]] <- hgt
}

enrichment.trt <- plyr::ldply(enrichment.list.trt, function(x) x) %>% 
  dplyr::rename("Trait" = ".id") %>% 
  ungroup() %>% 
  inner_join(nhood.length, "Neighborhood") %>% 
  filter(Size >= 10) %>% 
  mutate(padj = p.adjust(pval, method = adj.method)) %>% 
  group_by(Trait, Neighborhood) %>% 
  mutate(logpval = -log10(padj),
         EnrichmentScore = min(-log10(padj), -log10(10^-5))/-log10(10^-5)) %>% 
  ungroup() %>% 
  arrange(-EnrichmentScore) %>% mutate(EnrichmentBin = case_when(EnrichmentScore < 0.2 ~ 1,
                                                EnrichmentScore < 0.4 ~ 2,
                                                EnrichmentScore < 0.6 ~ 3,
                                                EnrichmentScore < 0.8 ~ 4,
                                                TRUE ~ 5)) 

#Inspect results
enrichment.trt %>% 
  filter(padj < 0.05) %>% 
  group_by(Trait) %>% 
  count()
```

Generate a data frame with all the members for each neighborhood
```{r}
neighborhood.tidy.list <- list()

for(node in nodes.ids){
  neighborhood.tidy.list[[node]] <- data.frame(Members = neighborhood.list[[node]])
}

neighborhood.tidy <- plyr::ldply(neighborhood.tidy.list, function(x) x) %>% 
  dplyr::rename("Neighborhood" = ".id") 
```

Identify the subnetwork that aggregates all the significant neighborhoods with an enrichment of T2-50 enriched vOTUs and generate a new network layout for plotting
```{r}
int.neighborhoods <- filter(enrichment.trt, Trait == "Dry") %>% 
  filter(padj < 0.05)

int.subntwk <- neighborhood.tidy %>% 
  filter(Neighborhood %in% int.neighborhoods$Neighborhood) %>% 
  group_by(Members) %>% 
  count() %>% 
  .$Members

nbhd.nodes <- GGally::ggnet2(as.matrix(filter(ntwk.filt, OTU1 %in% int.subntwk & OTU2 %in% int.subntwk)[,-3]), 
                mode = layout, 
                layout.par = list(list=(niter=2000))) %>% 
  .$data %>% 
  dplyr::rename("Genome" = "label")

nbhd.edges <- ntwk.filt %>% 
  mutate(Pair = paste(OTU1, OTU2, sep = ".")) %>% 
  gather(key = "Member", value = "Genome", -Pair, -Score) %>% 
  inner_join(nbhd.nodes, by = "Genome")
```

Save results
```{r}
saveRDS(nodes, "../Data/safe_ind_whole_nodes.RDS")
saveRDS(edges, "../Data/safe_ind_whole_edges.RDS")
saveRDS(nbhd.nodes, "../Data/safe_ind_subntwk_nodes.RDS")
saveRDS(nbhd.edges, "../Data/safe_ind_subntwk_edges.RDS")
saveRDS(enrichment.trt, "../Data/safe_ind_enrichment.RDS")
saveRDS(neighborhood.tidy, "../Data/safe_ind_eighborhoods.RDS")
```


